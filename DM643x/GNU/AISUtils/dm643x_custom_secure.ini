; General settings that can be overwritten in the host code
; that calls the AISGen library.
[General]

; Can be 8 or 16 - used in emifa
busWidth=8

; SPIMASTER,I2CMASTER,EMIFA,NAND,EMAC,UART,PCI,HPI,USB,MMC_SD,VLYNQ,RAW
BootMode=RAW

; 8,16,24 - used for SPI,I2C
;AddrWidth=8          

; NO_CRC,SECTION_CRC,SINGLE_CRC
crcCheckType=NO_CRC

; TRUE/ON or FALSE/OFF
seqReadEn=ON

; Specify the symbol name for the boot finalize function
;FinalFxnSymbolName=none


[Security]

; Security Type: GENERIC, CUSTOM
securityType=CUSTOM

; Boot Exit Type: NONSECURE, SECUREWITHSK, SECURENOSK
; NONSECURE = Device switches from secure type to non-secure type, jumping to loaded code 
;             (no secure kernel since no longer secure device).
; SECUREWITHSK = Device remains as secure type, secure kernel is loaded, allowing run-time
;                security context switching.
; SECURENOSK = Device remains as secure type, secure kernel is NOT loaded, no run-time
;              security context switching available.
BOOTEXITTYPE = SECUREWITHSK

; Encrypt section list (ALL or comma-separated list of section names)
encryptSections=ALL

; CEK used for AES encryption of data - must be string of 32 hexadecimal characters
encryptionKey=4A7E1F56AE545D487C452388A65B0C05

; Binary file containing RSA key info (public and private) for custom secure device
; Can be in PEM/DER format (OpenSSL), or XML format (Mono or .Net Framework)
rsaKeyFileName=priv_2048.key


; PLL0 configuration
;       |------24|------16|-------8|-------0|
; arg1: |    RSVD| CLKMODE|   PLLM | PLLDIV1|
;[PLL0CONFIG]
;PLL0CFG0 = 0x00001500


; PLL1 configuration
;       |------24|------16|-------8|-------0|
; arg1: |    RSVD|    PLLM| PLLDIV1| PLLDIV2|
;[PLL1CONFIG]
;PLL1CFG0 = 0x0017010B

;[PLLANDCLOCKCONFIG]
;PLL0CFG0 = 0x00001500
;PERIPHCLKCFG = 0x0000006D


; PLL1 and DDR configuration
;       |------24|---------16|-------8|-------0|
; arg1: |                PLL1CFG               |
; arg2: |               DDRPHYC1R              |
; arg3: |                SDCR                  |
; arg4: |                SDTIMR                |
; arg5: |                SDTIMR2               |
; arg6: |                SDRCR                 |
; arg7: |  RSVD  | vdd3p3vBit| gpioNum| useGpio|
;[EMIF3DDR]
;PLL1CFG0 = 0x0017010B
;DDRPHYC1R = 0x50006405
;SDCR = 0x00138822
;SDTIMR = 0x16492148
;SDTIMR2 = 0x000CC702
;SDRCR = 0x000004EF
;GPIONUM = 0x000B5801


; The EMIF section allows setting the AEMIF control registers of the 
; the DM643x device to the specified values. Only the five registers
; shown below can be set via the AIS method.
;       |------24|------16|-------8|-------0|
; arg1: |                A1CR               |
; arg2: |                A2CR               |
; arg3: |                A3CR               |
; arg4: |                A4CR               |
; arg5: |              NANDFCR              |
;[EMIF2ASYNC]
;A1CR = 0x0050043D
;A2CR = 0x3FFFFFFC
;A3CR = 0x3FFFFFFC
;A4CR = 0x3FFFFFFC
;NANDFCR = 0x00000000


; The PINMUX section allows setting the pinmux registers of the 
; the DM643x device to the specified values.
;       |------24|------16|-------8|-------0|
; arg1: |              regNum               |
; arg2: |               mask                |
; arg3: |              value                |
;[PINMUX]
;REGNUM = 
;MASK = 
;VALUE = 


; The LPSC sections are used to set the power domain STATE of the 
; specfied MODNUM power domain module. A seperate section must
; exist for each power domain you want to manipulate. The entries,
; are handled in the order present in this file, so the last 
; state set for a particular domain is the one that is used.
;       |------24|------16|-------8|-------0|
; arg1: |   RSVD | MODULE |   PD   | STATE  |
;[PSCCONFIG]
;LPSCCFG = 0x00000003

[TAPSCONFIG]
TAPSCFG=0xFFFFFFFF

